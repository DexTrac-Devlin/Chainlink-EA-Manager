#!/bin/bash

########################################################
#                Formatting Variables                  #
########################################################
b=$(tput bold)
n=$(tput sgr0)
un=$(tput smul)
nun=$(tput rmul)

########################################################
#                      Variables                       #
########################################################
IP_ADDRESS=$(ip route get 1.2.3.4 | awk '{print $7}')
VERSION="0.2.0"

# Grab API keys from flat file
source api_keys
# Grab Container names from flat file
source ~/.profile

# $1 --> option (--deploy)
# $2 --> external adapter name (--coingekco)
# $3 --> specific version for external adapter (0.1.4)

########################################################
#              EA CONFIG & URL RESOLUTION              #
########################################################
# Figure out repo root based on script location
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$SCRIPT_DIR"

EA_CONFIG="${EA_CONFIG:-$REPO_ROOT/ea_endpoints}"
EXTERNAL_DIR="${EXTERNAL_DIR:-$REPO_ROOT/externalAdapters}"

########################################################
# Regenerate ea_endpoints from externalAdapters comments
########################################################
sync_ea_config_from_external() {
  # If externalAdapters doesn't exist, just create an empty config and bail
  if [[ ! -d "$EXTERNAL_DIR" ]]; then
    {
      echo "# Auto-generated EA endpoints config"
      echo "# externalAdapters directory not found: $EXTERNAL_DIR"
      echo "# This file will be rebuilt whenever externalAdapters exists."
      echo
    } > "$EA_CONFIG"
    return 0
  fi

  # Rebuild ea_endpoints from scratch each time
  {
    echo "# Auto-generated EA endpoints config"
    echo "# Source of truth: comment headers in scripts under externalAdapters/"
    echo "# Format: <ea-name> <url>"
    echo
  } > "$EA_CONFIG"

  local f ea_name_found endpoint_found
  for f in "$EXTERNAL_DIR"/*; do
    [[ -f "$f" ]] || continue

    ea_name_found="$(
      grep -E '^# *ea-name:' "$f" 2>/dev/null \
        | head -n1 \
        | sed -E 's/^# *ea-name:[[:space:]]*//'
    )" || true

    endpoint_found="$(
      grep -E '^# *endpoint:' "$f" 2>/dev/null \
        | head -n1 \
        | sed -E 's/^# *endpoint:[[:space:]]*//'
    )" || true

    if [[ -n "$ea_name_found" && -n "$endpoint_found" ]]; then
      echo "$ea_name_found $endpoint_found" >> "$EA_CONFIG"
    fi
  done
}

########################################################
# Extract Docker image repository from adapter script
########################################################
get_adapter_image_repo() {
  local adapter_name="$1"
  local script_path="$EXTERNAL_DIR/$adapter_name"

  if [[ ! -f "$script_path" ]]; then
    echo "Error: Adapter script not found: $script_path" >&2
    exit 1
  fi

  # Extract the image repo (without tag) from the docker run command
  local repo=$(grep -o 'public.ecr.aws/chainlink/adapters/[^:]*' "$script_path" 2>/dev/null | head -1)

  if [[ -z "$repo" ]]; then
    echo "Error: Could not find Docker image in adapter script: $script_path" >&2
    exit 1
  fi

  printf '%s\n' "$repo"
}

########################################################
# Look up EA URL (with -redis fallback)
########################################################
resolve_ea_url_from_config() {
  local name="$1"

  sync_ea_config_from_external

  local url=""
  if [[ -f "$EA_CONFIG" ]]; then
    # 1) exact match
    url="$(
      awk -v n="$name" '
        NF && $1 !~ /^#/ && $1==n {print $2}
      ' "$EA_CONFIG" | head -n1
    )" || true

    # 2) if not found, try "<name>-redis" (to handle coinpaprika-state vs coinpaprika-state-redis)
    if [[ -z "$url" ]]; then
      local alt="${name}-redis"
      url="$(
        awk -v n="$alt" '
          NF && $1 !~ /^#/ && $1==n {print $2}
        ' "$EA_CONFIG" | head -n1
      )" || true
    fi
  fi

  if [[ -n "$url" ]]; then
    printf '%s\n' "$url"
    return 0
  fi

  # Still not found: fall back to interactive one-off URL
  echo "Warning: EA '$name' not found in externalAdapters comments / $(basename "$EA_CONFIG")." >&2
  echo "Add lines like these to the appropriate script under externalAdapters/:" >&2
  echo "  # ea-name: $name" >&2
  echo "  # endpoint: http://HOST:PORT" >&2
  echo >&2
  echo "For now, enter a URL to use just for this run (or leave blank to abort):" >&2

  local input_url=""
  if ! read -r input_url </dev/tty; then
    echo "Error: unable to read from /dev/tty." >&2
    exit 1
  fi

  if [[ -z "$input_url" ]]; then
    echo "No URL entered. Cannot continue for '$name'." >&2
    exit 1
  fi

  printf '%s\n' "$input_url"
}

########################################################
#            BASH COMPLETION FUNCTIONS                 #
########################################################
install_completion() {
  local completion_dir="$HOME/.local/share/bash-completion/completions"
  local completion_file="$completion_dir/eaManager"

  echo "${b}Installing bash completion...${n}"

  # Create directory if it doesn't exist
  mkdir -p "$completion_dir"

  # Write the completion script
  cat > "$completion_file" << 'EOF'
#!/usr/bin/env bash
# Bash completion for eaManager

_eaManager() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Find the eaManager script directory
    local script_dir=""
    if [[ -d "$HOME/Chainlink-EA-Manager" ]]; then
        script_dir="$HOME/Chainlink-EA-Manager"
    elif [[ -d "/usr/local/Chainlink-EA-Manager" ]]; then
        script_dir="/usr/local/Chainlink-EA-Manager"
    elif command -v eaManager >/dev/null 2>&1; then
        script_dir="$(dirname "$(readlink -f "$(command -v eaManager)")")"
    fi

    # Main options
    local main_opts="-i --initialize --init -d --deploy -u --upgrade --update -t --test -v --version -l --list -h --help --install-completion"

    # Test sub-options
    local test_opts="--ea --url --file --help -e -u -f -h"

    # Check if we're in test mode
    local in_test_mode=0
    for ((i=1; i<${#COMP_WORDS[@]}-1; i++)); do
        if [[ "${COMP_WORDS[i]}" == "-t" || "${COMP_WORDS[i]}" == "--test" ]]; then
            in_test_mode=1
            break
        fi
    done

    # Handle completions based on context
    case "${prev}" in
        -d|--deploy|-u|--upgrade|--update)
            # Complete with adapter names from externalAdapters/
            if [[ -d "$script_dir/externalAdapters" ]]; then
                local adapters=$(cd "$script_dir/externalAdapters" && ls -1 2>/dev/null)
                COMPREPLY=( $(compgen -W "${adapters}" -- ${cur}) )
            fi
            return 0
            ;;
        -t|--test)
            # After -t, offer test sub-options
            COMPREPLY=( $(compgen -W "${test_opts}" -- ${cur}) )
            return 0
            ;;
        --ea|-e)
            # Complete with EA names
            if [[ $in_test_mode -eq 1 ]]; then
                local ea_names=""
                if [[ -f "$script_dir/ea_endpoints" ]]; then
                    ea_names=$(grep -v '^#' "$script_dir/ea_endpoints" 2>/dev/null | awk '{print $1}')
                fi
                if [[ -z "$ea_names" ]] && [[ -d "$script_dir/externalAdapters" ]]; then
                    ea_names=$(cd "$script_dir/externalAdapters" && ls -1 2>/dev/null)
                fi
                COMPREPLY=( $(compgen -W "${ea_names}" -- ${cur}) )
            fi
            return 0
            ;;
        --file|-f)
            # Complete with files from requests/ directory
            if [[ -d "$script_dir/requests" ]]; then
                local request_files=$(cd "$script_dir/requests" && ls -1 2>/dev/null)
                local prefixed_files=$(cd "$script_dir/requests" && ls -1 2>/dev/null | sed 's|^|requests/|')
                COMPREPLY=( $(compgen -W "${request_files} ${prefixed_files}" -- ${cur}) )
            fi
            COMPREPLY+=( $(compgen -f -- ${cur}) )
            return 0
            ;;
        --url)
            return 0
            ;;
    esac

    # If in test mode, offer test options
    if [[ $in_test_mode -eq 1 ]] && [[ ! "${prev}" =~ ^- ]]; then
        COMPREPLY=( $(compgen -W "${test_opts}" -- ${cur}) )
        return 0
    fi

    # Default: complete with main options
    if [[ ${cur} == -* ]]; then
        if [[ $in_test_mode -eq 1 ]]; then
            COMPREPLY=( $(compgen -W "${test_opts}" -- ${cur}) )
        else
            COMPREPLY=( $(compgen -W "${main_opts}" -- ${cur}) )
        fi
        return 0
    fi

    # First argument: offer main options
    if [[ ${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "${main_opts}" -- ${cur}) )
        return 0
    fi
}

complete -F _eaManager eaManager
complete -F _eaManager ./eaManager
EOF

  chmod +x "$completion_file"

  echo "${b}✓ Completion installed to: ${n}$completion_file"
  echo ""
  echo "To activate completion, run one of:"
  echo "  ${b}source $completion_file${n}"
  echo "  ${b}exec bash${n}  (restart shell)"
  echo ""
  echo "Or add this to your ~/.bashrc to make it permanent:"
  echo "  ${b}source $completion_file${n}"
}

install_completion_quiet() {
  local completion_dir="$HOME/.local/share/bash-completion/completions"
  local completion_file="$completion_dir/eaManager"

  # Create directory if it doesn't exist
  mkdir -p "$completion_dir" 2>/dev/null

  # Write the completion script (same as above, but silent)
  cat > "$completion_file" 2>/dev/null << 'EOF'
#!/usr/bin/env bash
# Bash completion for eaManager

_eaManager() {
    local cur prev opts
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Find the eaManager script directory
    local script_dir=""
    if [[ -d "$HOME/Chainlink-EA-Manager" ]]; then
        script_dir="$HOME/Chainlink-EA-Manager"
    elif [[ -d "/usr/local/Chainlink-EA-Manager" ]]; then
        script_dir="/usr/local/Chainlink-EA-Manager"
    elif command -v eaManager >/dev/null 2>&1; then
        script_dir="$(dirname "$(readlink -f "$(command -v eaManager)")")"
    fi

    # Main options
    local main_opts="-i --initialize --init -d --deploy -u --upgrade --update -t --test -v --version -l --list -h --help --install-completion"

    # Test sub-options
    local test_opts="--ea --url --file --help -e -u -f -h"

    # Check if we're in test mode
    local in_test_mode=0
    for ((i=1; i<${#COMP_WORDS[@]}-1; i++)); do
        if [[ "${COMP_WORDS[i]}" == "-t" || "${COMP_WORDS[i]}" == "--test" ]]; then
            in_test_mode=1
            break
        fi
    done

    # Handle completions based on context
    case "${prev}" in
        -d|--deploy|-u|--upgrade|--update)
            # Complete with adapter names from externalAdapters/
            if [[ -d "$script_dir/externalAdapters" ]]; then
                local adapters=$(cd "$script_dir/externalAdapters" && ls -1 2>/dev/null)
                COMPREPLY=( $(compgen -W "${adapters}" -- ${cur}) )
            fi
            return 0
            ;;
        -t|--test)
            # After -t, offer test sub-options
            COMPREPLY=( $(compgen -W "${test_opts}" -- ${cur}) )
            return 0
            ;;
        --ea|-e)
            # Complete with EA names
            if [[ $in_test_mode -eq 1 ]]; then
                local ea_names=""
                if [[ -f "$script_dir/ea_endpoints" ]]; then
                    ea_names=$(grep -v '^#' "$script_dir/ea_endpoints" 2>/dev/null | awk '{print $1}')
                fi
                if [[ -z "$ea_names" ]] && [[ -d "$script_dir/externalAdapters" ]]; then
                    ea_names=$(cd "$script_dir/externalAdapters" && ls -1 2>/dev/null)
                fi
                COMPREPLY=( $(compgen -W "${ea_names}" -- ${cur}) )
            fi
            return 0
            ;;
        --file|-f)
            # Complete with files from requests/ directory
            if [[ -d "$script_dir/requests" ]]; then
                local request_files=$(cd "$script_dir/requests" && ls -1 2>/dev/null)
                local prefixed_files=$(cd "$script_dir/requests" && ls -1 2>/dev/null | sed 's|^|requests/|')
                COMPREPLY=( $(compgen -W "${request_files} ${prefixed_files}" -- ${cur}) )
            fi
            COMPREPLY+=( $(compgen -f -- ${cur}) )
            return 0
            ;;
        --url)
            return 0
            ;;
    esac

    # If in test mode, offer test options
    if [[ $in_test_mode -eq 1 ]] && [[ ! "${prev}" =~ ^- ]]; then
        COMPREPLY=( $(compgen -W "${test_opts}" -- ${cur}) )
        return 0
    fi

    # Default: complete with main options
    if [[ ${cur} == -* ]]; then
        if [[ $in_test_mode -eq 1 ]]; then
            COMPREPLY=( $(compgen -W "${test_opts}" -- ${cur}) )
        else
            COMPREPLY=( $(compgen -W "${main_opts}" -- ${cur}) )
        fi
        return 0
    fi

    # First argument: offer main options
    if [[ ${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "${main_opts}" -- ${cur}) )
        return 0
    fi
}

complete -F _eaManager eaManager
complete -F _eaManager ./eaManager
EOF

  chmod +x "$completion_file" 2>/dev/null
}

ensure_completion_installed() {
  local completion_file="$HOME/.local/share/bash-completion/completions/eaManager"
  if [[ ! -f "$completion_file" ]]; then
    install_completion_quiet
  fi
}

########################################################
#                 INITIALIZE FUNCTION                  #
########################################################
Initialize() {
# Initializes a new Docker environment
  echo "${b}Initializing new Docker environment...${n}"

  # Intall Docker if not already installed
  if [ $(dpkg-query -W -f='${Status}' docker-ce 2>/dev/null | grep -c "install ok installed") -eq 0 ];
  then
    # Check if running as root
    if [ "$EUID" -ne 0 ]
      then echo "${b}Run as elevated user (sudo)${n}"
      exit
    fi
    read -p "${b} Enter your non-root username:${n} " USERNAME
    aptInstall () {
      echo "${b}Updating apt & Installing Docker-CE${n}"
      apt-get -y update >>/dev/null 2>&1
      apt-get install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common >>/dev/null 2>&1
      curl -fsSL https://download.docker.com/linux/debian/gpg | apt-key add - >>/dev/null 2>&1
      add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable" >>/dev/null 2>&1
      apt-get -y update >>/dev/null 2>&1
      apt-get -y install docker-ce >>/dev/null 2>&1
      groupadd docker >>/dev/null 2>&1
      sudo usermod -aG docker $USERNAME >>/dev/null 2>&1
    }
    yumInstall (){
      echo "Updating yum"
      echo "Installing dependencies & Docker-CE"
      sudo yum remove docker* >>/dev/null 2>&1
      sudo yum -y update >>/dev/null 2>&1
      sudo yum -y remove docker* >>/dev/null 2>&1
      sudo yum -y install yum-utils >>/dev/null 2>&1
      sudo yum-config-manager \ --add-repo \ https://download.docker.com/linux/centos/docker-ce.repo  >>/dev/null 2>&1
      sudo yum -y install docker-ce docker-ce-cli containerd.io >>/dev/null 2>&1
      sudo systemctl start docker >>/dev/null 2>&1
      groupadd docker >>/dev/null 2>&1
      sudo usermod -aG docker $USERNAME >>/dev/null 2>&1
      sudo curl -L "https://github.com/docker/compose/releases/download/1.26.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose >>/dev/null 2>&1
      sudo chmod +x /usr/local/bin/docker-compose
      docker-compose --version
      sudo dnf install git -y
    }
    apt=`command -v apt-get`
    yum=`command -v yum`

    if [ -n "$apt" ]; then
      echo "apt detected"
      aptInstall
    elif [ -n "$yum" ]; then
      echo "yum detected"
      yumInstall
    else
      echo "Err: apt or yum not detected.";
      exit 1;
    fi
  fi

  # create docker network
  echo "${b}Creating Docker network...${n}"
  docker network create \
  --driver=bridge \
  --subnet=192.168.0.0/16 \
  --gateway=192.168.0.1 \
  eas-net

  # create directory to use for redis volume
if [ ! -d /home/mlzboy/b2c2/shared/db ]; then
  echo "${b}Creating Redis container...${n}"
  mkdir ~/.redis;
fi


  # deploy redis container
  echo ""
  echo "${b}Redis volume located at ~/.redis${n}"
  docker run \
  --name redis-cache \
  --restart=unless-stopped \
  --net eas-net \
  --ip=192.168.1.1 \
  -p 6379:6379 \
  -v ~/.redis:/data \
  -d redis redis-server --maxclients 2500

  # Provide Redis container information
  echo ""
  echo "${b}Redis container info:${n}"
  echo "containerName: redis-cache"
  echo "IPaddress: 192.168.1.1"
  echo "listnPort: 6379"

  # Copy eaManager script to PATH
  echo ""
  echo "Adding eaManager to PATH"
  sudo cp eaManager /usr/bin/eaManager

  # Install bash completion
  echo ""
  install_completion
}

########################################################
#                    DEPLOY FUNCTION                   #
########################################################
Deploy() {
  # Check if skopeo is installed, if not, install it
  if ! command -v skopeo &> /dev/null; then
    echo "skopeo could not be found, installing..."
    sudo apt-get update && sudo apt-get install -y skopeo
  fi

  # Get the actual image repository from the adapter script
  local repo=$(get_adapter_image_repo "$1")
  local adapter_name=$(basename "$repo" | sed 's/-adapter$//')
  local tags
  local tag_list
  local selected_tag

  echo "Fetching available tags for $adapter_name-adapter..."
  tags=$(skopeo list-tags "docker://$repo" | jq -r '.Tags[]' | sort -Vr | head -n 10)

  if [[ -z "$tags" ]]; then
    echo "No tags found for repository: $repo"
    exit 1
  fi

  # Display the tags and prompt the user for selection
  echo "Available tags for $repo:"
  tag_list=($tags)  # Convert tags into an array

  for i in "${!tag_list[@]}"; do
    echo "$i) ${tag_list[$i]}"
  done

  read -p "Select a tag (0-${#tag_list[@]}): " selected_index

  # Validate input and assign the selected tag
  if [[ "$selected_index" =~ ^[0-9]+$ ]] && [[ "$selected_index" -ge 0 ]] && [[ "$selected_index" -lt "${#tag_list[@]}" ]]; then
    selected_tag="${tag_list[$selected_index]}"
    echo "Selected tag: $selected_tag"
  else
    echo "Invalid selection."
    exit 1
  fi

  # Ensure selected_tag is not empty
  if [ -z "$selected_tag" ]; then
    echo "No tag selected, exiting."
    exit 1
  fi

  # Deploy the external adapter with the selected version using the corresponding bash script
  echo "Deploying $1 at version $selected_tag"

  # Ensure the script exists before attempting to execute it
  local deploy_script="externalAdapters/$1"
  if [[ ! -f "$deploy_script" ]]; then
    echo "Deployment script $deploy_script not found."
    exit 1
  fi

  # Run the deployment script with the selected tag
  bash "$deploy_script" "$selected_tag"
}

########################################################
#                  UPGRADE FUNCTION                    #
########################################################
Upgrade() {
  # Check if skopeo is installed, if not, install it
  if ! command -v skopeo &> /dev/null; then
    echo "skopeo could not be found, installing..."
    sudo apt-get update && sudo apt-get install -y skopeo
  fi

  # Get the actual image repository from the adapter script
  local repo=$(get_adapter_image_repo "$1")
  local adapter_name=$(basename "$repo" | sed 's/-adapter$//')
  local tags
  local tag_list
  local selected_tag

  echo "Fetching available tags for $adapter_name-adapter..."
  tags=$(skopeo list-tags "docker://$repo" | jq -r '.Tags[]' | sort -Vr | head -n 10)

  if [[ -z "$tags" ]]; then
    echo "No tags found for repository: $repo"
    exit 1
  fi

  # Display the tags and prompt the user for selection
  echo "Available tags for $repo:"
  tag_list=($tags)  # Convert tags into an array

  for i in "${!tag_list[@]}"; do
    echo "$i) ${tag_list[$i]}"
  done

  read -p "Select a tag (0-${#tag_list[@]}): " selected_index

  # Validate input and assign the selected tag
  if [[ "$selected_index" =~ ^[0-9]+$ ]] && [[ "$selected_index" -ge 0 ]] && [[ "$selected_index" -lt "${#tag_list[@]}" ]]; then
    selected_tag="${tag_list[$selected_index]}"
    echo "Selected tag: $selected_tag"
  else
    echo "Invalid selection."
    exit 1
  fi

  # Ensure selected_tag is not empty
  if [ -z "$selected_tag" ]; then
    echo "No tag selected, exiting."
    exit 1
  fi

  # Stop and remove the existing container
  echo "Stopping, removing, and redeploying $1 at version $selected_tag"
  docker stop "$1-redis"
  docker rm "$1-redis"

  # Ensure the script exists before attempting to execute it
  local upgrade_script="externalAdapters/$1"
  if [[ ! -f "$upgrade_script" ]]; then
    echo "Upgrade script $upgrade_script not found."
    exit 1
  fi

  # Run the upgrade script with the selected tag
  bash "$upgrade_script" "$selected_tag"
}

########################################################
#                  TEST FUNCTION                       #
########################################################
Test() {
  # Enhanced EA testing with flexible options
  local ea_name=""
  local ea_url=""
  local payload_file=""

  # Parse test-specific arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -e|--ea)
        ea_name="$2"
        shift 2
        ;;
      -u|--url)
        ea_url="$2"
        shift 2
        ;;
      -f|--file)
        payload_file="$2"
        shift 2
        ;;
      -h|--help)
        echo "Test Usage:"
        echo "  eaManager -t --ea <ea-name> [--file payload.json]"
        echo "  eaManager -t --url <EA_URL>  [--file payload.json]"
        echo ""
        echo "If --file is not provided, JSON is read from stdin (paste and Ctrl-D)."
        echo ""
        echo "Options:"
        echo "  -e, --ea    EA name (looked up via comments in externalAdapters and cached in ea_endpoints)"
        echo "  -u, --url   Full EA URL (bypass config / parsing)"
        echo "  -f, --file  JSON payload file"
        echo "  -h, --help  Show this help"
        echo ""
        echo "Examples:"
        echo "  eaManager -t --ea coinpaprika-state"
        echo "  eaManager -t --ea allium-state --file req.json"
        echo "  eaManager -t --url http://localhost:8010 --file req.json"
        exit 0
        ;;
      *)
        echo "Unknown argument for test: $1" >&2
        echo "Use 'eaManager -t --help' for test usage" >&2
        exit 1
        ;;
    esac
  done

  # Resolve URL
  if [[ -z "${ea_url:-}" ]]; then
    if [[ -z "${ea_name:-}" ]]; then
      echo "Error: you must provide either --ea <name> or --url <URL>" >&2
      echo "Use 'eaManager -t --help' for test usage" >&2
      exit 1
    fi

    ea_url="$(resolve_ea_url_from_config "$ea_name")"
  fi

  # Read payload
  local payload=""

  if [[ -n "${payload_file:-}" ]]; then
    if [[ ! -f "$payload_file" ]]; then
      echo "Error: payload file '$payload_file' not found." >&2
      exit 1
    fi
    payload="$(<"$payload_file")"
  else
    echo "Paste JSON payload, then press Ctrl-D:" >&2
    payload="$(cat)"
  fi

  if [[ -z "$payload" ]]; then
    echo "Error: empty payload." >&2
    exit 1
  fi

  # Validate JSON if jq exists
  if command -v jq >/dev/null 2>&1; then
    if ! echo "$payload" | jq empty >/dev/null 2>&1; then
      echo "Error: payload is not valid JSON (jq failed)." >&2
      exit 1
    fi
  fi

  # Fire request
  echo "⇒ POST $ea_url" >&2

  if command -v jq >/dev/null 2>&1; then
    curl -sS -X POST "$ea_url" \
      -H "Content-Type: application/json" \
      -d "$payload" | jq .
  else
    curl -sS -X POST "$ea_url" \
      -H "Content-Type: application/json" \
      -d "$payload"
  fi

  echo "⇐ Done" >&2
}

########################################################
#                  VERSION FUNCTION                    #
########################################################
Version() {
# Print Version
echo "eaManager version: ${b}$VERSION${n}"
}

########################################################
#                    LIST FUNCTION                     #
########################################################
List() {
# List EA options
echo "${b}Listing Supported EAs:${n}"
echo ""
tree externalAdapters
}

########################################################
#                    HELP FUNCTION                     #
########################################################
Help() {
  # Display Help
  echo "This script helps you deploy, manage, and upgrade your Chainlink external adapters."
  echo
  echo "Usage:  ${b}eaManager [option] [arguments]${n}"
  echo ""
  echo "Options:"
  echo ""
  echo "${b}-i, --initialize, --init${n}"
  echo "  Initializes a generic EA environment."
  echo "  Creates Docker network, deploys redis container,"
  echo "  use this if you want a quick turnkey deployment."
  echo ""
  echo "${b}-d, --deploy${n} <adapter-name>"
  echo "  Deploys new external adapter."
  echo "  ex: eaManager --deploy coingecko"
  echo ""
  echo "${b}-u, --upgrade, --update${n} <adapter-name>"
  echo "  Upgrades external adapter."
  echo "  ex: eaManager --upgrade coingecko"
  echo ""
  echo "${b}-t, --test${n} [options]"
  echo "  Send a test request to external adapter."
  echo "  ex: eaManager --test --ea coinpaprika-state"
  echo "  ex: eaManager --test --ea allium-state --file req.json"
  echo "  ex: eaManager --test --url http://localhost:8010 --file req.json"
  echo "  Use 'eaManager --test --help' for detailed test options"
  echo ""
  echo "${b}-v, --version${n}"
  echo "  Print script version and exit."
  echo ""
  echo "${b}-l, --list${n}"
  echo "  Print all supported EA names and exit."
  echo ""
  echo "${b}-h, --help${n}"
  echo "  Print this Help function and exit."
  echo ""
  echo "${b}--install-completion${n}"
  echo "  Install bash tab completion for eaManager."
  echo "  Enables auto-complete for all commands and adapter names."
  echo "  Also installed automatically during -i (Initialize)."
  echo
}

########################################################
#                        MAIN                          #
########################################################
# Silently ensure completion is installed
ensure_completion_installed

# Show help if no arguments
if [[ $# -eq 0 ]]; then
  Help
  exit 0
fi

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -i|--initialize|--init)
      Initialize
      exit 0
      ;;
    -d|--deploy)
      shift
      if [[ -z "$1" ]]; then
        echo "Error: --deploy requires an adapter name" >&2
        echo "Usage: eaManager --deploy <adapter-name>" >&2
        exit 1
      fi
      Deploy "$@"
      exit 0
      ;;
    -u|--upgrade|--update)
      shift
      if [[ -z "$1" ]]; then
        echo "Error: --upgrade requires an adapter name" >&2
        echo "Usage: eaManager --upgrade <adapter-name>" >&2
        exit 1
      fi
      Upgrade "$@"
      exit 0
      ;;
    -t|--test)
      shift
      Test "$@"
      exit 0
      ;;
    -v|--version)
      Version
      exit 0
      ;;
    -l|--list)
      List
      exit 0
      ;;
    -h|--help)
      Help
      exit 0
      ;;
    --install-completion)
      install_completion
      exit 0
      ;;
    *)
      echo "Unknown option: $1" >&2
      echo "Run 'eaManager --help' for usage information" >&2
      exit 1
      ;;
  esac
done
